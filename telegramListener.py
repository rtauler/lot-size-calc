import re
import csv

from telethon import TelegramClient, events, sync

from messageReader import readMessage
from calc import calcLot

from order import openOrder



#API info
api_id = 3215739
api_hash = '2ae75dcac0528a9fa786523608d96c3e'

client = TelegramClient('session_read', api_id, api_hash)

#L2T VIP CHANNEL:
#user_input_channel = -1001389726384
#TESTING
user_input_channel = 'me'

#inform that is running
print('Listening to',user_input_channel)

#key words to look for
subjectFilter = 'Instrument' and 'Stop Loss'

#import balance from MT4 calc.csv file (generated by a recurring script every 5 min)
acc_file = open('C:\\Users\\rtauler\\AppData\\Roaming\\MetaQuotes\\Terminal\\3E8BD1CBF618BD07B3A24E5C179C88CA\\MQL4\\Files\\Data\\acc.csv', 'r')
balance = float(acc_file.readline())

#listen to messages from target channel
@client.on(events.NewMessage(chats=user_input_channel))
async def newMessageListener(event):
	#Get message text
	newMessage = event.message.message
	#check if message contains the two keywords defined in subjectFilter
	if subjectFilter in newMessage:
		print('----ORIGINAL MSG-------')
		print(newMessage)
		#extract the data of the message into a list
		print('----EXTRACTED DATA-----')
		extData = readMessage(newMessage)
		print(extData)
		#extract the specifics in the list
		print('----CALCULATED LOT-----')
		for i in extData:
			if 'Symbol' == i[0]:
				symbol = i[1]
			elif 'EntryPrice' == i[0]:
				entry_price = i[1]
			elif 'StopLoss' == i[0]:
				stop_loss = i[1]
			elif 'TakeProfit1' == i[0]:
				man_tp = i[1]
			elif 'Risk' == i[0]:
				risk = i[1]

		#calculate the lot size
		opLot = calcLot(symbol,balance,float(risk),float(2),float(entry_price),float(stop_loss),man_tp,'')
		print(opLot)

		print('---JOINED LIST------')

		#generate a list with the balance
		balance_arr = [['Balance',balance]]

		#join the data from the order + the balance + the lot calculation
		op = extData + balance_arr + opLot
		print(op)

		#send a message to user 
		await client.send_message('me', str(op))

		print(op[0][1],op[7][1])

		openOrder(op[0][1].upper(),op[7][1])

#infinite loop to keep listening the channel
with client:
	client.run_until_disconnected()


